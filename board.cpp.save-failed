#include "board.h"
#include "square.h"
#include "pawn.h"
#include <map>
#include <string>
#include <cctype>
#include <cmath>

using namespace std;

//sprawdzic czy pionek przy pierwszym ruchu moze przeskakiwac przez pionka swojego koloru

///////////////////////////////////////////// METODY KLASY BOARD /////////////////////////////////////////////////////////


void Board::printBoard() {

	cout << endl << endl;
	for (int i = 0; i < 8; i++)
	{
		cout << " " << 8-i << "   ";
		for (int j = 0; j < 8; j++)
		{

			Piece p = square[i][j].getPiece();
			Color c = square[i][j].getColor();

			switch (p)
			{
			case KING: (c == WHITE) ? cout << " K_b |" : cout << " K_c |";
				break;
			case QUEEN: (c == WHITE) ? cout << " H_b |" : cout << " H_c |";
				break;
			case BISHOP:(c == WHITE) ? cout << " G_b |" : cout << " G_c |";
				break;
			case KNIGHT:(c == WHITE) ? cout << " S_b |" : cout << " S_c |";
				break;
			case ROOK: (c == WHITE) ? cout << " W_b |" : cout << " W_c |";
				break;
			case PAWN: (c == WHITE) ? cout << " P_b |" : cout << " P_c |";
				break;
			case EMPTY: cout << "     |";
				break;
			//default: cout << "XXX";
				break;
			}

		}
		cout << "\n";

		cout << endl;
	}
	cout << "       A     B     C     D     E     F     G     H " << "\n\n";

	square[6][2].occupiedBy()->display();

	cout << "\n\n";
}

bool Board::doMove() {
	string toSquare, fromSquare;
	int x1, x2, y1, y2;
	bool stop = false;

	map<char, int> board_references = {
            { 'A', 0 },
            { 'B', 1 },
            { 'C', 2 },
            { 'D', 3 },
            { 'E', 4 },
            { 'F', 5 },
            { 'G', 6 },
            { 'H', 7 },
            { '1', 7 },
            { '2', 6 },
            { '3', 5 },
            { '4', 4 },
            { '5', 3 },
            { '6', 2 },
            { '7', 1 },
            { '8', 0 }
        };

	while (!stop)
	{
	    	bool st_from = false;
            bool st_to = false;

            (turn == WHITE) ? cout << "White's turn\n\n" : cout << "Black's turn\n\n";

           while(!st_from){

                cout << "Pole figury, ktora chcesz ruszyc (np. A8): ";
                cin >> fromSquare;

                if(fromSquare.length() < 3){

                    x1 = board_references.find(fromSquare.back())->second;
                    y1 = board_references.find(toupper(fromSquare.front()))->second;

                    if (getSquare(x1, y1)->occupiedBy()->isWhite()){
                            if(x1 > 8 || y1 > 8 || isdigit(fromSquare.front()) || !isdigit(fromSquare.back())){
                                cout << "Takie pole nie istnieje! \n";
                            }
                            else{
                                st_from = true;
                            }
                        }
                    else
                        cout << "To nie jest Twoj pionek. Sprobuj jeszcze raz." << endl;
                }
                else cout << "Podaj poprawne pole!\n";
            }

            while(!st_to){
                cout << "Dokad chcesz sie ruszyc? (np. B5): ";
                cin >> toSquare;

                if(toSquare.length() < 3){
                    x2 = board_references.find(toSquare.back())->second;
                    y2 = board_references.find(toupper(toSquare.front()))->second;

                    if (getSquare(x1, y1)->occupiedBy()->isWhite()){

                        if(x2 > 8 || y2 > 8 || isdigit(toSquare.front()) || !isdigit(toSquare.back())){
                            cout << "Takie pole nie istnieje! \n";
                        }
                        else{
                            st_to = true;
                        }
                    }
                    else
                        cout << "To nie jest Twoj pionek. Sprobuj jeszcze raz." << endl;
                }
                else cout << "Podaj poprawne pole!\n";
            }

            if (makeMove(x1, y1, x2, y2) == false)
            {
                cout << "Tu jest niby falsz" << endl;
            }
            else
                cout << "Ten ruch byl poprawny";
                stop = true;

	}

	if (turn == BLACK){
		turn = WHITE;}
	else
		turn = BLACK;

	return true;

}

void Board::setBoard()
{
    Piece2* aPiece;

	square[7][0].setPieceAndColor(ROOK, WHITE);
	square[7][1].setPieceAndColor(KNIGHT, WHITE);
	square[7][2].setPieceAndColor(BISHOP, WHITE);
	square[7][3].setPieceAndColor(QUEEN, WHITE);
	square[7][4].setPieceAndColor(KING, WHITE);
	square[7][5].setPieceAndColor(BISHOP, WHITE);
	square[7][6].setPieceAndColor(KNIGHT, WHITE);
	square[7][7].setPieceAndColor(ROOK, WHITE);

	square[0][0].setPieceAndColor(ROOK, BLACK);
	square[0][1].setPieceAndColor(KNIGHT, BLACK);
	square[0][2].setPieceAndColor(BISHOP, BLACK);
	square[0][3].setPieceAndColor(QUEEN, BLACK);
	square[0][4].setPieceAndColor(KING, BLACK);
	square[0][5].setPieceAndColor(BISHOP, BLACK);
	square[0][6].setPieceAndColor(KNIGHT, BLACK);
	square[0][7].setPieceAndColor(ROOK, BLACK);

	aPiece = new Pawn(true);
	for (int i = 0; i < 8; i++)
	{
		//square[6][i].setPieceAndColor(PAWN, WHITE);
		square[1][i].setPieceAndColor(PAWN, BLACK);
		square[6][i].setOccupier(aPiece);

	}
	for (int i = 2; i < 6; i++)
	{
		for (int j = 0; j < 8; j++)
			square[i][j].setPieceAndColor(EMPTY, NONE);

	}
	for (int i = 0; i < 8; i++)
		for (int j = 0; j < 8; j++)
		{
			square[i][j].setX(i);
			square[i][j].setY(j);
		}

}

bool Board::playGame()
{
	//system("cls");
	printBoard();
	return doMove();

}

/////////////////////////////////////// ODT¥D W DÓ£ JEDYNIE RUCHY PIONKÓW ////////////////////////////////////////////////
bool Board::isClearHorizontal(Square* thisPiece, Square* thatSpace){

    int pieceX = thisPiece->getX();
	int pieceY = thisPiece->getY();
	int thatY = thatSpace->getY();
	int j;
	bool valid = true;

	if (pieceY < thatY){

        for(j = pieceY + 1; j < thatY; j++ ){

            if (getSquare(pieceX, j)->getColor() != NONE){
                valid = false;
            }
        }
	}
	else{
        for(j = pieceY - 1; j > thatY; j-- ){

            if (getSquare(pieceX, j)->getColor() != NONE){
                valid = false;
            }
        }
	}
	return valid;
}

bool Board::isClearVertical(Square* thisPiece, Square* thatSpace){

    int pieceX = thisPiece->getX();
	int pieceY = thisPiece->getY();
	int thatX = thatSpace->getX();
	int i;
	bool valid = true;

	if (pieceX < thatX){

        for(i = pieceX + 1; i < thatX; i++ ){

            if (getSquare(i, pieceY)->getColor() != NONE){
                valid = false;
            }
        }
	}
	else{
        for(i = pieceX - 1; i > thatX; i-- ){

            if (getSquare(i, pieceY)->getColor() != NONE){
                valid = false;
            }
        }
	}
	return valid;
}

bool Board::isClearDiagonal(Square* thisPiece, Square* thatSpace){

    int pieceX = thisPiece->getX();
	int pieceY = thisPiece->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();
	int i;
	bool valid = true;

	if (pieceX > thatX && pieceY < thatY){

            for(i = 1; i < (thatY - pieceY); i++){

                if (getSquare(pieceX - i, pieceY + i)->getColor() != NONE){
                    valid = false;
                }
            }
	}
	else if (pieceX > thatX && pieceY > thatY){
         for(i = 1; i < (pieceY - thatY); i++){

                if (getSquare(pieceX - i, pieceY - i)->getColor() != NONE){
                    valid = false;
                }
            }
	}
	else if (pieceX < thatX && pieceY < thatY){
         for(i = 1; i < (thatY - pieceY); i++){

                if (getSquare(pieceX + i, pieceY + i)->getColor() != NONE){
                    valid = false;
                }
            }
	}
	else if (pieceX < thatX && pieceY > thatY){
         for(i = 1; i < (pieceY - thatY); i++){

                if (getSquare(pieceX + i, pieceY - i)->getColor() != NONE){
                    valid = false;
                }
            }
	}
	return valid;
}

bool Board::moveKing(Square* thisKing, Square* thatSpace) {
	int kingX = thisKing->getX();
	int kingY = thisKing->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();


	if (thisKing->getColor() == WHITE)
	{

		if (abs(kingX - thatX) < 2 && abs(kingY - thatY) < 2
            && (thatSpace->getColor() == NONE || thatSpace->getColor() == BLACK)
            && thatSpace->getPiece() != KING)
		{
			thatSpace->setSpace(thisKing);
			thisKing->setEmpty();
			return true;
		}
		else
            return false;
	}
	else
		if (thisKing->getColor() == BLACK)
		{
			if (abs(kingX - thatX) < 2 && abs(kingY - thatY) < 2
                && (thatSpace->getColor() == NONE || thatSpace->getColor() == WHITE)
                && thatSpace->getPiece() != KING)
			{
				thatSpace->setSpace(thisKing);
				thisKing->setEmpty();
				return true;
			}
			else
                return false;
		}

    else
        {
            return false;
        }


}
bool Board::moveQueen(Square* thisQueen, Square* thatSpace) {

	if (thisQueen->getColor() == WHITE)
	{

		if ((thatSpace->getColor() == NONE || thatSpace->getColor() == BLACK)
            && isClearVertical(thisQueen, thatSpace) && isClearHorizontal(thisQueen, thatSpace)
            && isClearDiagonal(thisQueen, thatSpace) && thatSpace->getPiece() != KING)
		{
			thatSpace->setSpace(thisQueen);
			thisQueen->setEmpty();
			return true;
		}
		else
			return false;
	}
	else
		if (thisQueen->getColor() == BLACK)
		{
			if ((thatSpace->getColor() == NONE || thatSpace->getColor() == WHITE)
            && isClearVertical(thisQueen, thatSpace) && isClearHorizontal(thisQueen, thatSpace)
            && isClearDiagonal(thisQueen, thatSpace) && thatSpace->getPiece() != KING)

			{
				thatSpace->setSpace(thisQueen);
				thisQueen->setEmpty();
				return true;
			}
			else
				return false;
		}
    else
    {
        return false;
    }
}

bool Board::moveBishop(Square* thisBishop, Square* thatSpace) {
	int bishopX = thisBishop->getX();
	int bishopY = thisBishop->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();

	if (thisBishop->getColor() == WHITE)
	{
		if (abs(bishopX - thatX) == abs(bishopY - thatY) && (thatSpace->getColor() == NONE || thatSpace->getColor() == BLACK)
            && isClearDiagonal(thisBishop, thatSpace) && thatSpace->getPiece() != KING)
		{
			thatSpace->setSpace(thisBishop);
			thisBishop->setEmpty();
			return true;
		}
		else
			return false;
	}
	else
		if (thisBishop->getColor() == BLACK)
		{
			if (abs(bishopX - thatX) == abs(bishopY - thatY) && (thatSpace->getColor() == NONE || thatSpace->getColor() == WHITE)
                && isClearDiagonal(thisBishop, thatSpace) && thatSpace->getPiece() != KING)
			{
				thatSpace->setSpace(thisBishop);
				thisBishop->setEmpty();
				return true;
			}
			else
				return false;
		}
    else
    {
        return false;
    }

}

bool Board::moveKnight(Square* thisKnight, Square* thatSpace)
{
	int knightX = thisKnight->getX();
	int knightY = thisKnight->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();

	if (thisKnight->getColor() == WHITE)
	{
		if (((abs(knightX - thatX) == 2 && abs(knightY - thatY) == 1) || (abs(knightX - thatX) == 1 && abs(knightY - thatY) == 2))
            && (thatSpace->getColor() == NONE || thatSpace->getColor() == BLACK) && thatSpace->getPiece() != KING)
		{
			thatSpace->setSpace(thisKnight);
			thisKnight->setEmpty();
			return true;
		}
		else
			return false;
	}
	else
		if (thisKnight->getColor() == BLACK)
		{
			if (((abs(knightX - thatX) == 2 && abs(knightY - thatY) == 1) || (abs(knightX - thatX) == 1 && abs(knightY - thatY) == 2))
                && (thatSpace->getColor() == NONE || thatSpace->getColor() == WHITE) && thatSpace->getPiece() != KING)
			{
				thatSpace->setSpace(thisKnight);
				thisKnight->setEmpty();
				return true;
			}
			else
				return false;
		}
    else
    {
        return false;
    }

}

bool Board::moveRook(Square* thisRook, Square* thatSpace)
{
	int rookX = thisRook->getX();
	int rookY = thisRook->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();

	if (thisRook->getColor() == WHITE)
	{

		if (( abs(rookX - thatX) < 8 && thatY == rookY && thatSpace->getColor() == NONE
            && isClearVertical(thisRook, thatSpace))
            || (abs(rookY - thatY) < 8 && thatX == rookX && thatSpace->getColor() == NONE
            && isClearHorizontal(thisRook, thatSpace)))
		{
			thatSpace->setSpace(thisRook);
			thisRook->setEmpty();
			return true;
		}
		else
			if (( abs(rookX - thatX) < 8 && thatY == rookY && thatSpace->getColor() == BLACK
                && isClearVertical(thisRook, thatSpace) && thatSpace->getPiece() != KING)
                || (abs(rookY - thatY) < 8 && thatX == rookX && thatSpace->getColor() == BLACK
                && isClearHorizontal(thisRook, thatSpace) && thatSpace->getPiece() != KING))
			{
				thatSpace->setSpace(thisRook);
				thisRook->setEmpty();
				return true;
			}
			else
				return false;
	}
	else
		if (thisRook->getColor() == BLACK)
		{
			if ((abs(rookX - thatX) < 8 && thatY == rookY && thatSpace->getColor() == NONE
                && isClearVertical(thisRook, thatSpace))
                || (abs(rookY - thatY) < 8 && thatX == rookX && thatSpace->getColor() == NONE
                && isClearHorizontal(thisRook, thatSpace)))
			{
				thatSpace->setSpace(thisRook);
				thisRook->setEmpty();
				return true;
			}
			else
				if ((abs(rookX - thatX) < 8 && thatY == rookY  && thatSpace->getColor() == WHITE
                    && isClearVertical(thisRook, thatSpace) && thatSpace->getPiece() != KING)
                    || (abs(rookY - thatY) < 8 && thatX == rookX && thatSpace->getColor() == WHITE
                    && isClearHorizontal(thisRook, thatSpace) && thatSpace->getPiece() != KING))
				{
					thatSpace->setSpace(thisRook);
					thisRook->setEmpty();
					return true;
				}
				else
					return false;
		}
    else
    {
        return false;
    }
}


bool Board::movePawn(Square* thisPawn, Square* thatSpace) {

	int pawnX = thisPawn->getX();
	int pawnY = thisPawn->getY();
	int thatX = thatSpace->getX();
	int thatY = thatSpace->getY();


	if (thisPawn->getColor() == WHITE)
	{

		if ((pawnX == thatX + 1 && thatY == pawnY && thatSpace->getColor() == NONE)
            || (pawnX == thatX + 2 && thatY == pawnY && thatSpace->getColor() == NONE
                && pawnX == 6 && getSquare(pawnX - 1, pawnY)-> getColor() == NONE))
		{
			thatSpace->setSpace(thisPawn);
			thisPawn->setEmpty();

			return true;
		}
		else
			if ((pawnY + 1 == thatY || pawnY - 1 == thatY) && pawnX - 1 == thatX  && thatSpace->getColor() == BLACK
                && thatSpace->getPiece() != KING)
			{
				thatSpace->setSpace(thisPawn);
				thisPawn->setEmpty();
				return true;
			}
			else
				return false;
	}
	else
		if (thisPawn->getColor() == BLACK)
		{
			if ((pawnX == thatX -1 && thatY == pawnY && thatSpace->getColor() == NONE)
                ||(pawnX == thatX -2 && thatY == pawnY && thatSpace->getColor() == NONE
                   && pawnX == 1 && getSquare(pawnX + 1, pawnY)->getColor()== NONE))
			{
				thatSpace->setSpace(thisPawn);
				thisPawn->setEmpty();
				return true;
			}
			else
				if ((pawnY + 1 == thatY || pawnY - 1 == thatY) && pawnX + 1 == thatX
                    && thatSpace->getColor() == WHITE && thatSpace->getPiece() != KING)
				{
					thatSpace->setSpace(thisPawn);
					thisPawn->setEmpty();
					return true;
				}
				else
					return false;
		}
    else
        {
            return false;
        }
}

bool Board::makeMove(int x1, int y1, int x2, int y2) {
	/*if (x1 < 0 || x1>7 || y1 < 0 || y1>7 || x2 < 0 || x2>7 || y2 < 0 || y2>8)
	{
		std::cout << "One of your inputs was out of bounds" << std::endl;
		return false;
	}*/
	Square* src = getSquare(x1, y1);
	Square* dest = getSquare(x2, y2);

	if (!src->occupiedBy()->isWhite()) //== dest->occupiedBy()->isWhite())
	{
		std::cout << "Invalid move: cannot land on your own piece" << std::endl;
		return false;
	}
    if(src->occupiedBy()->moveTo(src, dest))
    {
        cout << "Przeciez jest ok";
        return true;
    }

    /*
	switch (src->getPiece())
	{
	case KING: return moveKing(src, dest);
		break;
	case QUEEN: return moveQueen(src, dest);
		break;
	case BISHOP: return moveBishop(src, dest);
		break;
	case KNIGHT: return moveKnight(src, dest);
		break;
	case ROOK: return moveRook(src, dest);
		break;
	case PAWN: return movePawn(src, dest);
		break;
	case EMPTY: std::cout << "You do not have a piece there" << std::endl;  return false;
		break;
	}*/
	return false;
}

